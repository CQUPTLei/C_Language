5B
/*
* File_name：respond.c
* Author：dahu
* Description：定义了不同功能码的响应函数
* Time：2021-04-21
* encoding：UTF-8
* Version：1.0
*/


#include<stdio.h>
#include"respond.h"



/*********************************************************************************************
* 功能：模拟16路DI、DO、AI、AO
* 说明：使用的Modbus/TCP master ,使用了01 02 03 04功能码
*      前两个以bit为基本单位，16路即2bytes；后两个以word为基本单位，16路即32bytes（16words）。
* 注意：连续两个寄存器之间存在字节序和大小端的问题，需注意
*********************************************************************************************/
byte coil[2] = {0x00,0x00};    //读线圈/离散量输出状态（ON/OFF）   01    bit   16路DO:0000 0000 0000 0000(高到低)
byte relay[2] = {0x0f,0x06};   //读离散量输入值（ON/OFF）         02    bit   16路DI:0000 0110 0000 1111(高到低)
byte holding_reg[32] = {0x01,0x01,0x01,0x02,0x00,0x03,0x00,0x04,0x00,0x05,0x00,0x06,0x00,0x07,0x00,0x08,
						0x00,0x01,0x00,0x02,0x00,0x03,0x00,0x04,0x00,0x05,0x00,0x06,0x00,0x07,0x00,0x08,};     
                               //读保持寄存器值                   03    word  (响应报文按字节来的，这里不用word定义了)
byte input_reg[32] = {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};       
                               //读输入寄存器值                   04    word    全为0x0101,即257




/*********************************************************************************************
* 名称：solve_01(SOCKET clntSock, byte request[], byte coil[])
* 功能：01功能码，读线圈/离散量输出状态
* 入口参数：clnSock：客户端socket，request:接收数据缓冲区，coil：事先准备好的线圈/离散量状态输出值
* 返回参数：无
* 说明：收到报文的关键部分为：01（1byte）+ 起始地址(2bytes)+ 寄存器数(2bytes)。
*      例如： 02 00 00 00 06表示读取0x0000开始的6个线圈的状态（1个线圈占用1位，共1个字节）
*      返回报文关键部分为：02(1byte)+ N(1byte)+ n=N/N+1字节状态(n bytes)
*      对上诉例子的响应：02 01 01
*上面只是关键部分报文分析，完整报文符合server.c中我写的 Modbus TCP报文格式
**********************************************************************************************/
void solve_01(SOCKET clntSock, byte request[], byte coil[]) {
	int len, n;
	len = request[11];                                                     //需要读取的点的个数
	n = (len % 8) == 0 ? (len / 8) : (len / 8 + 1);                        //对应的的字节数
	byte send_buff[8 + 3] = { 0x00,0x00,0x00,0x00,0x00,0x06,0x01,0x02 };   //返回数据缓冲区，前八个字节不变（除了长度位），后面最多3个字节
	send_buff[5] = 2 + 1 + n;                                              //确定响应报文第六位，即后续报文长度：01+02+n+n bytes data
	send_buff[8] = 2 * n;                                                  //我用的是Modbus/TCP这个软件来测试的，软件有点小问题，n要乘以2，正确的报文这里不需要乘以2  
	for (int i = 0;i < n;i++) {
		send_buff[i + 9] = coil[i];
	}
	printf("\n该指令为读线圈/离散量状态输出即DO,返回内容应该为：\n");
	for (int i = 0;i < 8 + 1 + n;i++)printf("0x0%x ", send_buff[i]);
	printf("\n**************************************************************************************************");
	send(clntSock, send_buff, 8 + 1 + n, 0);                               //响应请求
}




/*********************************************************************************************
* 名称：solve_02(SOCKET clntSock, byte request[], byte relay[])
* 功能：02功能码，读离散量输入
* 入口参数：clnSock：客户端socket，request:接收数据缓冲区，relay：事先准备好的离散量输入值
* 返回参数：无
* 说明：同01功能码
**********************************************************************************************/
void solve_02(SOCKET clntSock, byte request[], byte relay[]) {
	int len,n;
	len = request[11];                                                   //需要读取的点的个数
	n = (len % 8) == 0 ? (len/8):(len/8+1);                              //对应的的字节数
	byte send_buff[8 + 3] = { 0x00,0x00,0x00,0x00,0x00,0x06,0x01,0x02 }; //返回数据缓冲区，前八个字节不变（除了长度位），后面最多3个字节
	send_buff[5] = 2+1+n;                                                //确定响应报文第六位，即后续报文长度：01+02+n+n bytes data
	send_buff[8] = 2*n;                                                  //我用的是Modbus/TCP这个软件来测试的，软件有点小问题，n要乘以2，正确的报文这里不需要乘以2  
	for (int i = 0;i < n;i++) {
		send_buff[i + 9] = relay[i];
	}
	printf("\n该指令为读离散量输入即DI,返回内容应该为：\n");
	for (int i = 0;i < 8+1+n;i++)printf("0x0%x ", send_buff[i]);
	printf("\n**************************************************************************************************");
	send(clntSock, send_buff, 8+1+n, 0);                                 //响应请求
}




/*********************************************************************************************
* 名称：solve_03(SOCKET clntSock, byte request[], byte holding_reg[])
* 功能：03功能码，读保持寄存器
* 入口参数：clnSock：客户端socket，request:接收数据缓冲区，holding_reg：事先准备好的保持寄存器
* 返回参数：无
* 说明：类似01功能码，不在赘述
**********************************************************************************************/
void solve_03(SOCKET clntSock,byte request[],byte holding_reg[]) {
	int len, n;
	len = request[11];                                                       //需要读取的寄存器的个数
	n = 2 * len;                                                             //对应的的字节数
	byte send_buff[8 + 33] = { 0x00,0x00,0x00,0x00,0x00,0x06,0x01,0x03 };    //返回数据缓冲区，前八个字节不变（除了长度位），后面最多33个字节
	send_buff[5] = 2 + 1 + n;                                                //确定响应报文第六位，即后续报文长度：01+02+n+n bytes data
	send_buff[8] = n;                                                        //我用的是Modbus/TCP这个软件来测试的，软件有点小问题，n要乘以2，正确的报文这里不需要乘以2  
	for (int i = 0;i < n;i++) {
		send_buff[i + 9] = holding_reg[i];
	}
	printf("\n该指令为读保持寄存器,返回内容应该为：\n");
	for (int i = 0;i < 8 + 1 + n;i++)printf("0x0%x ", send_buff[i]);
	printf("\n**************************************************************************************************");
	send(clntSock, send_buff, 8 + 1 + n, 0);                                 //响应请求
}




/*********************************************************************************************
* 名称：solve_04(SOCKET clntSock, byte request[], byte input_reg[])
* 功能：04功能码，读输入寄存器
* 入口参数：clnSock：客户端socket，request:接收数据缓冲区，relay：事先准备好的离散量输入值
* 返回参数：无
* 说明：同01功能码
**********************************************************************************************/
void solve_04(SOCKET clntSock, byte request[], byte input_reg[]) {
	int len, n;
	len = request[11];                                                       //需要读取的寄存器的个数
	n = 2 * len;                                                             //对应的的字节数
	byte send_buff[8 + 33] = { 0x00,0x00,0x00,0x00,0x00,0x06,0x01,0x04 };    //返回数据缓冲区，前八个字节不变（除了长度位），后面最多33个字节
	send_buff[5] = 2 + 1 + n;                                                //确定响应报文第六位，即后续报文长度：01+02+n+n bytes data
	send_buff[8] = n;                                                        //我用的是Modbus/TCP这个软件来测试的，软件有点小问题，n要乘以2，正确的报文这里不需要乘以2  
	for (int i = 0;i < n;i++) {
		send_buff[i + 9] = input_reg[i];
	}
	printf("\n该指令为读输入寄存器,返回内容应该为：\n");
	for (int i = 0;i < 8 + 1 + n;i++)printf("0x0%x ", send_buff[i]);
	printf("\n**************************************************************************************************");
	send(clntSock, send_buff, 8 + 1 + n, 0);                                 //响应请求
}






/*********************************************************************************************
* 名称：solve_all(SOCKET clnSock,byte request[])
* 功能：对 功能码进行判别，并转到相应的功能码的处理函数
* 入口参数：clnSock：客户端socket，request:接收数据缓冲区
* 返回参数：无
* 说明：无
**********************************************************************************************/
void solve_all(SOCKET clnSock,byte request[]) {
	switch (request[7]) {
		case 1:solve_01(clnSock,request,coil);break;
		case 2:solve_02(clnSock,request,relay);break;    //DI 读离散量输入
		case 3:solve_03(clnSock,request, holding_reg);break;
		case 4:solve_04(clnSock,request,input_reg);break;
	}
}
