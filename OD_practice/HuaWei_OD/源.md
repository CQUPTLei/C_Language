



# <font color=red>100分</font>—————————————————————

# 01 猜字谜 （0179）（字符串字符统计比较）

**题目描述**

小王设计了一个简单的猜字谜游戏，游戏的谜面是一个错误的单词，比如`nesw`，玩家需要猜出谜底库中正确的单词。
猜中的要求如下：
对于某个谜面和谜底单词，满足下面任一条件都表示猜中：

1. 变换顺序以后一样的，比如通过变换`w`和`e`的顺序，`nwes`跟`news`是可以完全对应的；
2. 字母去重以后是一样的，比如`woood`和`wood`是一样的，它们去重后都是`wod`

请你写一个程序帮忙在谜底库中找到正确的谜底。
谜面是多个单词，都需要找到对应的谜底，如果找不到的话，返回`not found`

**输入描述**

1. 谜面单词列表，以`,`分隔
2. 谜底库单词列表，以`,`分隔

**输出描述**

匹配到的正确单词列表，以`,`分隔
如果找不到，返回`not found`

**备注**

1. 单词的数量N的范围：0<*N*<1000
2. 词汇表的数量M的范围： 0<*M*<1000
3. 单词的长度P的范围：0<*P*<20
4. 输入的字符只有小写英文字母，没有其它字符

**示例一**

**输入**

```plaintext
conection
connection,today
```

**输出**

```plaintext
connection
```

**示例二**

**输入**

```plaintext
bdni,wooood
bind,wrong,wood
```

**输出**

```plaintext
bind,wood
```

**思路**

1. 去重后是否相等：统计每个字符**是否出现**（不计算次数），完全一致，则猜中。
2. 变换顺序是否相等：那么每个字符出现的**次数相同**……
3. 上述条件满足任意一个即猜中。





# 02   最短木板长度（0150）（数组）



**题目描述**

小明有*n*块木板，第i*(1≤*i*≤*n)块木板长度为$$a_i$$。
小明买了一块长度为m的木料，这块木料可以切割成任意块，
拼接到已有的木板上，用来加长木板。
小明想**让最短的木板尽量长**。
请问小明加长木板后，最短木板的长度可以为多少？

**输入描述**

输入的第一行包含两个正整数，$$n(1≤n≤10^3),m(1≤m≤10^6)$$
*n*表示木板数，m*表示木板长度。
输入的第二行包含n*个正整数，$$a_1,a_2,...a_n(1≤a_i≤10^6)$$，表示原来每块木板的长度。

**输出描述**

输出的唯一一行包含一个正整数，表示加长木板后，最短木板的长度最大可以为多少？

**示例一**

**输入**

```plaintext
5 3
4 5 3 5 5
```

**输出**

```plaintext
5
```

**说明**

给第1块木板长度增加1，给第3块木板长度增加2后，
这5块木板长度变为`[5,5,5,5,5]`，最短的木板的长度最大为5。

**示例二**

**输入**

```plaintext
5 2
4 5 3 5 5
```

**输出**

```plaintext
4
```

**说明**

给第3块木板长度增加1后，
这5块木板长度变为`[4,5,4,5,5]`，剩余的木料长度为1。
此时剩余木料无论给哪块木板加长，最短木料的长度都为4。



**思路：**

- 最小木板的长度范围为1至max(len)，其中len为所有木板的长度和加上m。

- 对于每个mid值，检查是否可能把所有木板加成长度不小于mid。如果可以，可以尝试让最小长度更长，否则缩小最小长度的范围。满足条件的mid的最大值就是答案。

时间复杂度：O(n log(max(len)))

（最小长度的范围为1至max(len)，因此使用long long类型存储mid、len和max_len。）







# 03 找出重复代码（0177）（公共子串 动态规划）



**题目描述**

小明负责维护项目下的代码，需要**查找出重复代码**，用以支撑后续的代码优化，请你帮助小明找出重复的代码。
重复代码查找方法：以**字符串**形式给出**两行**代码（字符串长度`1 < length <= 100`，由英文字母、数字和空格组成），找出两行代码中的**最长公共子串**。
注：如果不存在公共子串，返回空字符串。

**输入描述**

输入的参数`text1，text2`分别表示两行代码

**输出描述**

输出任一最长公共子串

**示例一**

**输入**

```plaintext
hello123world
hello123abc4
```

**输出**

```plaintext
hello123
```

**示例二**

**输入**

```plaintext
private_void_method
public_void_method
```

**输出**

```plaintext
_void_method
```

**示例三**

 **输入**

```plaintext
hiworld
hiweb
```

 **输出**

```plaintext
hiw
```



**思路：**

使用动态规划求解最长公共子串。

具体做法：

1. 用一个二维数组`dp[i][j]`表示以第一个字符串第`i`个字符和第二个字符串第`j`个字符结尾的最长公共子串的长度。
2. 当`text1[i-1]`等于`text2[j-1]`时，`dp[i][j] = dp[i-1][j-1]+1`；否则，`dp[i][j] = 0`。
3. 每次更新`dp[i][j]`时，都要与当前的最大公共子串长度`max_len`比较，如果大于等于`max_len`，则更新`max_len`和`end_index`（公共子串在第一个字符串中的结束位置）的值。
4. 最后根据`max_len`和`end_index`，求出公共子串。



# 04  查找单入口空闲区域（0180）（递归、DFS搜索、数组）

**题目描述**

给定一个 m*×*n的矩阵，由若干字符 `X` 和 `O`构成，
`X`表示该处已被占据，`O`表示该处空闲，请找到最大的单入口空闲区域。

空闲区域是**由连通的`O`组成的区域**，位于**边界的`O`可以构成入口**，

**单入口空闲区域即有且只有一个位于边界的`O`作为入口的由连通的`O`组成的区域。**
如果**两个元素在水平或垂直方向相邻，则称它们是“连通”的**。

**输入描述**

第一行输入为两个数字，
\1. 第一个数字为行数 *m*，
\2. 第二个数字列数 *n*，两个数字以空格分隔，
1≤*m*,*n*≤200

剩余各行为矩阵各行元素，元素为`X` 或 `O`，各元素间以空格分隔。

**输出描述**

若有唯一符合要求的最大单入口空闲区域，输出三个数字，

1. 第一个数字为入口行坐标（范围为0~行数-1），
2. 第二个数字为入口列坐标（范围为0~列数-1），
3. 第三个数字为区域大小，三个数字以空格分隔；

若有多个符合要求的最大单入口空闲区域，输出一个数字，代表区域的大小；
若没有，输出`NULL`。

**示例一**

**输入**

```plaintext
4 4
X X X X
X O O X
X O O X
X O X X
```

**输出**

```plaintext
3 1 5
```



 **说明**

存在最大单入口区域，入口行坐标`3`，列坐标`1`，区域大小`5`

 **示例二**

 **输入**

```plaintext
4 5
X X X X X
O O O O X
X O O O X
X O X X O
```


 **输出**

```plaintext
3 4 1
```


 **说明**

存在最大单入口区域，入口行坐标`3`，列坐标`4`，区域大小`1`

**示例三**

 **输入**

```plaintext
5 4
X X X X
X O O O
X O O O
X O O X
X X X X
```



 **输出**

```plaintext
NULL
```

说明

没有

 **示例四**

**输入**

```plaintext
5 4
X X X X
X O O O
X X X X
X O O O
X X X X
```



 **输出**

```plaintext
3
```


 **说明**

存在两个大小为3的最大单入口区域，两个入口横纵坐标分别为`1,3`和`3,3`





**思路：**

用DFS/BFS求解（深度/广度优先遍历）。由于一个最大的单入口空闲区域恰好由边界上的一个O作为入口，因此可以:

1. 先分别遍历矩阵的四个边界，对每个为O的位置分别进行DFS/BFS搜索，找到其所在的最大连通域，

2. 将这些最大连通域按照大小从大到小排序，输出最大的连通域大小及其入口位置。

   

   注意需要特别处理没有单入口空闲区域和出现多个符合要求的情况。时间复杂度为O(nmlog(nm))。

   



# 05 单词倒序（0181）（字符串）



**题目描述**

输入单行英文句子，里面包含英文字母，空格以及`,` `.` `?` 三种标点符号，
请将句子内**每个单词进行倒序**，并输出倒序后的语句。

**输入描述**

输入字符串`S`，`S`的长度`1 <= N <= 100`

**输出描述**

输出逆序后的字符串

**备注**

```
标点符号左右的空格 >= 0，单词间空格 > 0
```

**示例一**

**输入**

```plaintext
yM eman si boB.
```

**输出**

```plaintext
My name is Bob.
```

**示例二**

**输入**

```plaintext
woh era uoy ? I ma enif.
```

**输出**

```plaintext
how are you ? I am fine.
```

**思路**

- 遍历字符串，遇到非符号压入栈；

- 遇到符号，将栈中元素全部出栈覆盖原有字符串，并跳过符号开始需要下一个乱序单词。

（或者循环判断是否遇到分隔符，遇到则将前面的逆序输出，再输出分隔符，再讲位置移动到分隔符后面）



# 06 打印文件（0182）（优先级队列）



**题目描述**

有5台打印机打印文件，每台打印机有自己的待打印队列。
因为打印的文件内容有轻重缓急之分，所以队列中的文件有`1~10`不同的优先级，其中数字越大优先级越高。
打印机会从自己的待打印队列中选择优先级最高的文件来打印。
如果存在两个优先级一样的文件，则选择最早进入队列的那个文件。
现在请你来模拟这`5`台打印机的打印过程。

**输入描述**

每个输入包含1个测试用例

每个测试用例第1行给出发生事件的数量N*(0<*N*<1000)。
接下来有 N* 行，分别表示发生的事件。
共有如下两种事件：

1. `IN P NUM`，表示有一个拥有优先级 `NUM` 的文件放到了打印机 `P` 的待打印队列中。(0<*P*≤5,0<*N**U**M*≤10)；
2. `OUT P`，表示打印机 `P` 进行了一次文件打印，同时该文件从待打印队列中取出。(0<*P*≤5)。

**输出描述**

对于每个测试用例，每次`OUT P`事件，请在一行中输出文件的编号。
如果此时没有文件可以打印，请输出`NULL`。
文件的编号定义为：`IN P NUM`事件发生第 `X` 次，此处待打印文件的编号为 `X`。编号从`1`开始。

**示例一**

**输入**

```plaintext
7
IN 1 1
IN 1 2
IN 1 3
IN 2 1
OUT 1
OUT 2
OUT 2
```

**输出**

```plaintext
3
4
NULL
```

**示例二**

**输入**

```plaintext
5
IN 1 1
IN 1 3
IN 1 1
IN 1 3
OUT 1
```

**输出**

```plaintext
2
```



**思路：**

使用优先级队列，其中**优先级由文件的优先级和进队列的时间决定**。对于IN事件，将文件的编号、打印机号、优先级和进队列的时间存入优先级队列。对于OUT事件，取出队首文件并输出。

时间复杂度：O(N log N)



# 07 对称美学（0159）（字符串、递归）

**题目描述**

对称就是最大的美学，现有一道关于对称字符串的美学。
已知：
第 1 个字符串：`R`
第 2 个字符串：`BR`
第 3 个字符串：`RBBR`
第 4 个字符串：`BRRBRBBR`
第 5 个字符串：`RBBRBRRBBRRBRBBR`
相信你已经发现规律了，没错！
`就是第i个字符串 = 第i-1号字符串的取反 + 第i-1号字符串`。
取反即(`R->B`, `B->R`);
现在告诉你 `n` 和 `k` ，让你求得第`n`个字符串的第`k`个字符是多少。
(`k`的编号从`0`开始)

**输入描述**

第一行输入一个 *T* ，表示有 T 组用例：
接下来输入 *T* 行，每行输入两个数字， 表示 *n* ，*k*
`1 <= T <= 100`;
`1 <= n <= 64`;
`0 <= k < 2^(n-1)`;

**输出描述**

输出 *T* 行表示答案：
输出 `blue` 表示字符是`B`；
输出 `red` 表示字符是`R`；

**示例一**

**输入**

```plaintext
5
1 0
2 1
3 2
4 6
5 8
```

**输出**

```plaintext
red
red
blue
blue
blue
```

**说明**

第 1 个字符串：`R -> 第 0 个字符为R`
第 2 个字符串：`BR -> 第 1 个字符为R`
第 3 个字符串：`RBBR -> 第 2 个字符为B`
第 4 个字符串：`BRRBRBBR -> 第 6 个字符为B`
第 5 个字符串：`RBBRBRRBBRRBRBBR -> 第 8 个字符为B`

**示例二**

**输入**

```plaintext
1
64 73709551616
```

**输出**

```plaintext
red
```

**说明**

**备注**

输出字符串区分大小写，请注意输出小写字符串，不带双引号



**思路：**

- 使用递归的方法来解决。
- 定义一个函数 `char find(int n, long long k)` 来返回第 n 个字符串的第 k 个字符。当 n 等于 1 时，直接返回 ‘R’。
- 否则，判断 k 是否小于 2^(n-2)。
- 如果是，那么返回 `find(n-1, k)` 的取反；
- 否则，返回 `find(n-1, k - (1 << (n-2)))`。

> 
>
> 由于第 i 个字符串是由第 i-1 个字符串的取反和第 i-1 个字符串本身拼接而成的，所以第 n 个字符串的前一半（即前 2^(n-2) 个字符）是第 n-1 个字符串的取反，后一半（即后 2^(n-2) 个字符）是第 n-1 个字符串本身。
>
> 因此，我们首先判断 k 是否小于 2^(n-2)。如果是，说明我们要查找的字符在第 n 个字符串的前一半，也就是第 n-1 个字符串的取反中。所以我们返回 `find(n-1, k)` 的取反。否则，说明我们要查找的字符在第 n 个字符串的后一半，也就是第 n-1 个字符串本身中。所以我们返回 `find(n-1, k - (1 << (n-2)))`。
>
> `k - (1 << (n-2))` 的意思是将 k 减去 2^(n-2)。
>
> 由于第 n 个字符串的后一半（即后 2^(n-2) 个字符）是第 n-1 个字符串本身，所以当我们要查找的字符在第 n 个字符串的后一半时，我们需要将 k 减去 2^(n-2) 来得到它在第 n-1 个字符串中的位置。
>
> 例如，假设 n=4，那么第 4 个字符串是 “BRRBRBBR”。如果我们要查找第 6 个字符（k=5），那么我们需要将 k 减去 2^(4-2)=4，得到 k=1。然后我们就可以递归地查找第 3 个字符串的第 1 个字符，也就是 “R”。





# 08 分界线（0161）（字符串、排序）

**题目描述**

电视剧《分界线》里面有一个片段，男主为了向警察透露案件细节，且不暴露自己，于是将报刊上的字剪下来，剪拼成匿名信。
现在又一名举报人，希望借鉴这种手段，使用英文报刊完成举报操作。
但为了增加文章的混淆度，只需满足**每个单词中字母数量一致即可，不关注每个字母的顺序**。
解释：单词`on`允许通过单词`no`进行替代。
报纸代表`newspaper`,匿名信代表`anonymousLetter`,
求报纸内容是否可以拼成匿名信。

**输入描述**

输入描述
第一行输入`newspaper`内容，包括`1-N`个字符串，用空格分开
第二行输入`anonymousLetter`内容，包括`1-N`个字符串，用空格分开

1. `newspaper`和`anonymousLetter`的字符串由小写英文字母组成，且**每个字母只能使用一次**
2. `newspaper`内容中的每个字符串字母顺序可以任意调整，但必须保证字符串的完整性（每个字符串不能有多余字母）
3. `1 < N < 100`,`1 <= newspaper.length,anonymousLetter.length <= 10^4`

**输出描述**

如果报纸可以拼成匿名信返回true，否则返回false

**示例一**

**输入**

```plaintext
ab cd
ab
```

**输出**

```plaintext
true
```

**示例二**

**输入**

```plaintext
ab ef
aef
```

**输出**

```plaintext
false
```

**示例三**

**输入**

```plaintext
ab bcd ef
cbd fe
```

**输出**

```plaintext
true
```

**示例四**

**输入**

```plaintext
ab bcd ef
cd fe
```

**输出**

```plaintext
false
```



**思路：**

计算letter和newspaper中每个单词中字符出现的次数，比较就行了。和猜字谜那个差不多。





# 09 端口合并（0145）（数组、递归）



**题目描述**

有`M(1<=M<=10)`个端口组，
每个端口组是长度为`N(1<=N<=100)`的整数数组，
如果端口组间存在2个及以上端口相同，
则认为这2个端口组互相关联，可以合并
第一行输入端口组个数M，再输入M行，每行逗号分隔，代表端口组。
输出合并后的端口组，用二维数组表示

**输入描述**

第一行输入一个数字M
第二行开始输入M行，每行是长度为N的整数数组，用逗号分割

**输出描述**

合并后的二维数组

**示例一**

**输入**

```plaintext
4
4
2,3,2
1,2
5
```

**输出**

```plaintext
[[4],[2,3,1],[5]]
```

**说明**

仅有一个端口2相同，不可以合并

**示例二**

**输入**

```plaintext
3
2,3,1
4,3,2
5
```

**输出**

```plaintext
[[1,2,3,4],[5]]
```



**示例三**

**输入**

```plaintext
6
10
4,2,1
9
3,6,9,2
6,3,4
8
```

**输出**

```plaintext
[[10],[1,2,3,4,6,9],[9],[8]]
```



**思路：**

主要思路是通过迭代地合并端口组来实现题目要求的功能。

- 首先读取输入数据并将其存储在一个二维数组中。
- 然后，将输入数据复制到一个新的二维数组`merged`中，用于存储合并后的端口组。
- 接下来，用一个`while`循环，该循环会一直执行，直到没有新的端口组可以合并为止。
- 在每次迭代中，代码会遍历`merged`数组中的所有端口组，并检查它们是否可以与其他端口组合并。如果两个端口组之间有两个及以上相同的端口，则它们可以合并。
- 代码会调用一个辅助函数`merge_port_groups`来合并这两个端口组，并将结果存储在`merged`数组中。
- 当`while`循环结束时，所有可以合并的端口组都已经被合并。最后，代码遍历`merged`数组并输出合并后的端口组。



`qsort`是C语言中的一个库函数，它用于对数组进行快速排序。它的函数原型如下：

```c
void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void*))
```

其中，`base`是指向要排序的数组的指针，`nitems`是数组中元素的个数，`size`是每个元素的大小（以字节为单位），`compar`是一个比较函数，用于比较两个元素。

比较函数的原型如下：

```c
int compar(const void *a, const void *b)
```

它接受两个指针作为参数，并返回一个整数。如果`a`应该排在`b`之前，则返回一个负数；如果`a`应该排在`b`之后，则返回一个正数；如果两者相等，则返回0。

例如，在上面的代码中，我们使用了如下的比较函数：

```c
int cmp(const void *a, const void *b) {
    return *(int *)a - *(int *)b;
}
```

这个比较函数用于对整数数组进行升序排序。它将两个指针强制转换为整数指针，并计算它们所指向的整数之差。如果第一个整数小于第二个整数，则返回一个负数；如果第一个整数大于第二个整数，则返回一个正数；否则返回0。



# 10 货币单位换算（0183）（字符串）

**题目描述**

记账本上记录了若干条多国货币金额，需要转换成人民币分（`fen`），汇总后输出。
每行记录一条金额，金额带有货币单位，格式为`数字+单位`，可能是单独元，或者单独分，或者元与分的组合。
要求将这些货币全部换算成人民币分（`fen`）后进行汇总，汇总结果仅保留整数，小数部分舍弃。
元和分的换算关系都是`1:100`，如下：
`1CNY=100fen（1元=100分）`
`1HKD=100cents（1港元=100港分）`
`1JPY=100sen（1日元=100仙）`
`1EUR=100eurocents（1欧元=100欧分）`
`1GBP=100pence（1英镑=100便士）`
汇率如下表

| CNY  | JPY  | HKD  | EUR  | GBP  |
| ---- | ---- | ---- | ---- | ---- |
| 100  | 1825 | 123  | 14   | 12   |

即`100CNY = 1825JPY = 123HKD = 14EUR = 12GBP`

**输入描述**

第一行输入为 *N* 表示记录数。0<*N*<100
之后 N行，每行表示一条货币记录，且该行只会是一种货币。

**输出描述**

将每行货币转换成人民币分（`fen`）后**汇总求和**，只保留整数部分。
输出格式只有整数数字，不带小数，不带单位。

**示例一**

**输入**

```plaintext
1
100CNY
```

**输出**

```plaintext
10000
```

**说明**

```
100CNY`转换后是`10000fen`，所以输出结果为`10000
```

**示例二**

**输入**

```plaintext
1
3000fen
```

**输出**

```plaintext
3000
```

**说明**

```
3000fen`，结果就是`3000
```

**示例三**

**输入**

```plaintext
1
123HKD
```

**输出**

```plaintext
10000
```

**说明**

```
HKD`与`CNY`的汇率关系是`123:100`，所以换算后，输出结果为`10000
```

**示例四**

**输入**

```plaintext
2
20CNY53fen
53HKD87cents
```

**输出**

```plaintext
6432
```

**说明**

```
20元53分+53港元87港分`，换算成人民币分后汇总，为`6432
```



思路：

很简单。





# 11 获得完美走位（0184）（字符串、滑窗）



**题目描述**

在第一人称射击游戏中，玩家通过键盘的`A`、`S`、`D`、`W`四个按键控制游戏人物分别向左、向后、向右、向前进行移动，从而完成走位。
假设玩家每按动一次键盘，游戏人物会向某个方向移动一步，如果玩家在**操作一定次数的键盘并且各个方向的步数相同时，此时游戏人物必定会回到原点，则称此次走位为完美走位。**
现给定玩家的走位（例如：`ASDA`）,请通过更换其中一段连续走位的方式使得原走位能够变成一个完美走位。
其中待更换的连续走位可以是相同长度的任何走位。
请返回待更换的连续走位的最小可能长度。
若果原走位本身是一个完美走位，则返回`0`。

**输入描述**

输入为由键盘字母表示的走位`s`，例如：`ASDA`

**输出描述**

输出为待更换的连续走位的最小可能长度

**备注**

1. 走位长度$$ 1≤s.length≤10^5$$
2. `s.length` 是 `4` 的倍数
3. `s` 中只含有 `A`, `S`, `D`, `W` 四种字符

**示例一**

**输入**

```plaintext
ASDW
```

**输出**

```plaintext
0
```

**说明**

已经是完美走位了。

**示例二**

**输入**

```plaintext
AASW
```

**输出**

```plaintext
1
```

**说明**

需要把一个`A`更换成`D`，这样可以得到`ADSW`或者`DASW`。

**示例三**

**输入**

```plaintext
AAAA
```

**输出**

```plaintext
3
```

**说明**

可以替换后 `3` 个 `A`，得到`ASDW`。



思路：

题目：每个方向步数相同。

再参考示例3，是4个方向步数相同。而且输入是4的倍数，直接计算即可。





# 12 简单的自动曝光（）（数组）









# 13 日志采集系统（0186）（数组）



**题目描述**

日志采集是运维系统的的核心组件。日志是按行生成，每行记做一条，由采集系统分批上报。
如果上报太频繁，会对服务端造成压力；
如果上报太晚，会降低用户的体验；
如果一次上报的条数太多，会导致超时失败。
为此，项目组设计了如下的上报策略：

1. 每成功上报一条日志，奖励`1`分
2. 每条日志每延迟上报`1`秒，扣`1`分
3. 积累日志达到`100`条，必须立即上报
   给出日志序列，根据该规则，计算**首次上报能获得的最多积分数**。

**输入描述**

按时序产生的日志条数 $$T_1,T_2,...T_n$$, 其中$$1≤n≤1000,0≤T_i≤100$$

**输出描述**

首次上报最多能获得的积分数

**示例一**

**输入**

```plaintext
1 98 1
```

**输出**

```plaintext
98
```

**说明**

采集系统第2个时刻上报，可获得最大积分`(98+1)-1=98`

**示例二**

**输入**

```plaintext
50 60 1
```

**输出**

```plaintext
50
```

**说明**

如果`第1个时刻`上报，获得积分`50`。
如果`第2个时刻`上报，最多上报`100`条，前`50`条延迟上报`1s`，每条扣除`1`分，共获得积分为 `100-50=50`。



思路：

回溯法，从最后一项开始向前计算最大积分即可。



# 14 数组的中心位置（0187）（数组、前缀和）



**题目描述**

给你一个整数数组`nums`,请**计算数组的中心位置**。
数组中心位置是数组的一个**下标**，其**左侧所有元素相乘的积等于右侧所有元素相乘的积**。
数组第一个元素的左侧积为`1`，最后一个元素的右侧积为`1`。
如果数组有多个中心位置，应该**返回最靠近左边的那一个**。
如果数组不存在中心位置，返回`-1`。

**输入描述**

输入只有一行，给出 *N* 个正整数用空格分格：`nums = 2 5 3 6 5 6`
`1 <= nums.length <= 1024`
`1 <= nums[i] <= 10`

**输出描述**

输出：中心位置的下标

**示例一**

**输入**

```plaintext
2 5 3 6 5 6
```

**输出**

```plaintext
3
```

**说明**

中心位置下标是`3`，即数字6.
左侧数之积 `sum = nums[0] * nums[1] * nums[2] = 2 * 5 * 3 = 30` ，
右侧数之积 `sum = nums[4] * nums[5] = 5 * 6 = 30` ，二者相等。



思路：

- 先将所有元素乘起来，总的积；
- 然后循环，更新左侧和右侧积
- 其中：左侧积等于左侧元素依次相乘，右侧积则等于总的积除以当前元素。
- 这样就可以同时更新左右积了，然后比较即可。
- 因为是从左边向右边比较的，所以有多个中心点时，也是输出最左边的中心点下标。





# 15 xx通信误码（0169）（滑窗）

**题目描述**

信号传播过程中会出现一些误码，不同的数字表示不同的误码ID，取值范围为1~65535，用一个数组记录误码出现的情况，每个误码出现的次数代表误码频度，请找出记录中**包含频度最高误码的最小子数组长度**。

**输入描述**

误码总数目：取值范围为`0~255`，取值为0表示没有误码的情况。
误码出现频率数组：误码ID范围为`1~65535`，数组长度为`1~1000`。

**输出描述**

包含频率最高的误码最小子数组长度

**示例一**

**输入**

```plaintext
5 
1 2 2 4 1
```

**输出**

```plaintext
2
```

**说明**

频度最高的有`1`和`2`，频度是`2`（出现的次数都是`2`）。
可以包含频度最高的记录数组是`[2 2]`和`[1 2 2 4 1]`，
最短是`[2 2]`，最小长度为`2`

**示例二**

**输入**

```plaintext
7 
1 2 2 4 2 1 1
```

**输出**

```plaintext
4
```

**说明**

频度最高的是`1`和`2`，最短的是`[2 2 4 2]`





思路：

解题思路
1、统计各字符出现频次，找到出现频次最高的字符
2、找到最高频次字符的下标并计算出差值
3、所有差值中最小的就是最小子数组长度





# 16 xx网上商城优惠活动（一）（0188）（贪心、数组、排序）

​	

**题目描述**

- 背景
  某网上商城举办优惠活动，发布了满减、打折、无门槛3种优惠券，分别为：
  1. 每满`100`元优惠`10`元，无使用数限制，如`100~199`元可以使用`1`张减`10`元，`200~299`可使用`2`张减`20`元，以此类推；
  2. `92`折券，`1`次限使用`1`张，如`100`元，则优惠后为`92`元；
  3. 无门槛`5`元优惠券，无使用数限制，直接减`5`元。
- 优惠券使用限制
  每次最多使用`2`种优惠券，`2`种优惠可以叠加（优惠叠加时以优惠后的价格计算），
  以购物`200元`为例，可以先用`92`折券优惠到`184元`，再用`1`张满减券优惠`10元`，最终价格是`174元`，
  也可以用满减券`2`张优惠`20元`为`180元`，再使用`92`折券优惠到`165`（165.6向下取整）元，
  不同使用顺序的优惠价格不同，以最优惠价格为准。
  在一次购物中，同一类型优惠券使用多张时必须一次性使用，
  不能分多次拆开穿插使用（不允许先使用1张满减券，再用打折券，再使用一张满减券）。
- 问题
  请设计实现一种解决方法，帮助购物者以最少的优惠券获得最优的优惠价格。
  优惠后价格越低越好，同等优惠价格，使用的优惠券越少越好，可以允许某次购物不使用优惠券。
- 约定
  优惠活动每人只能参加一次，每个人的优惠券种类和数量是一样的。

**输入描述**

第一行：每个人拥有的优惠券数量（数量取值范围为`[0, 10]`），按满减、打折、无门槛的顺序输入。
第二行：表示购物的人数`n（1 <= n <= 10000）`。

最后n行：每一行表示某个人优惠前的购物总价格（价格取值范围`(0, 1000]`，都为整数）。

约定：输入都是符合题目设定的要求的。

**输出描述**

每行输出每个人每次购物优惠后的最低价格以及使用的优惠券总数量，每行的输出顺序和输入的顺序保持一致。

**备注**

1. 优惠券数量都为整数，取值范围为`[0, 10]`。
2. 购物人数为整数，取值范围为`[1, 10000]`。
3. 优惠券的购物总价为整数，取值范围为`(0, 1000]`。
4. 优惠后价格如果是小数，则向下取整，输出都为整数。

**示例一**

**输入**

```plaintext
3 2 5
3
100
200
400
```

**输出**

```plaintext
65 6
155 7
338 4
```

**说明**

**输入说明**

第一行：3种优惠券数量分别为满减券3张，打折券2张，无门槛5张
第二行：总共3个人购物
第三行：第一个人购物优惠前价格为100元
第四行：第二个人购物优惠前价格为200元
第五行：第三个人购物优惠前价格为400元

**输出说明**

输入3个人，输出3行结果，同输入的顺序，对应每个人的优惠结果，如下：
第一行：先使用1张满减券优惠到90元，再使用5张无门槛券优惠25元，最终价格是65元，总共使用6张优惠券
第二行：先使用2张满减券优惠到180元，再使用5张无门槛券优惠25元，最终价格是155元，总共使用7张优惠券
第三行：先使用1张92折券优惠到368元，再使用3张满减券优惠30元，最终价格是338元，总共使用4张优惠券

**思路**

看似复杂，其实是简单计算和逻辑判断
首先设计三个函数分别计算当前金额对每种优惠券使用后的结果，如代码中`useT1` `useT2` `useT3`
之后分情况讨论：

1. 小于等于62元，优先使用优惠券3
2. 优惠券1和2比较后，再分情况比较2、3和1、3





# 17 开心消消乐（0167）（深度、广度搜索）



**题目描述**

给定一个 *N* 行 *M* 列的二维矩阵，矩阵中每个位置的数字取值为 0 或 1，矩阵示例如：

```plaintext
1 1 0 0
0 0 0 1
0 0 1 1
1 1 1 1
```

现需要将矩阵中所有的 1 进行反转为 0，规则如下：

1. 当点击一个 1 时，该 1 被反转为 0，同时相邻的上、下、左、右，以及左上、左下、右上、右下8个方向的 1 （如果存在1）均会自动反转为 0；
2. 进一步地，一个位置上的 1 被反转为 0 时，与其相邻的8个方向的 1 （如果存在11）均会自动反转为 0；
   按照上述规则示例中的矩阵只最少需要点击2次后，所有均值 0 。请问，给定一个矩阵，最少需要点击几次后，所有数字均为0？

**输入描述**

第一行输入两个整数，分别表示矩阵的行数 *N* 和列数 *M*，取值范围均为 [1,100]
接下来 *N* 行表示矩阵的初始值，每行均为 *M* 个数，取值范围 [0,1]

**输出描述**

输出一个整数，表示最少需要点击的次数

**示例一**

**输入**

```plaintext
3 3
1 0 1
0 1 0
1 0 1
```

**输出**

```plaintext
1
```

**说明**

上述样例中，四个角上的 1 均在中间的 1 的相邻8个方向上，因此只需要点击一次即可。

**示例二**

**输入**

```plaintext
4 4
1 1 0 0
0 0 0 1
0 0 1 1
1 1 1 1
```

**输出**

```plaintext
2
```

**说明**

在上述 4×4 的矩阵中，只需要点击2次，即可将所有的 11 进行消除。











# 18获取最大软件版本号（）（字符串、排序）









# <font color=red>2022 Q4 A卷</font>-----------------------------------------------------------------



1. 汇率
2. 箱子之字形摆放
3. Excel单元格数值统计
4. 全排列
5. 新词挖掘
6. 最优资源分配
7. 模拟商场优惠打折
8. 投篮大赛
9. 通信误码
10. 日志采集



- 信号发射与接收（递减栈）
- Linux发行版的数量（并查集）
- **网上商城优惠活动（逻辑分析）**
- 天然蓄水库（双指针）
- 组合出最小合法数（字典序、逻辑分析）
- 单词倒序（逻辑分析）
- 硬件产品销售方案（全组合）
- 递增字符串（动态规划）
- 寻找相似单词（排序）
- 微服务的集成测试（拓扑排序）
- 农场施肥（二分查找）
- 组装新的数组（全组合）
- 新员工座位（字符串排序）
- **快速开租建站（拓扑排序）**
- **荒地（动态规划、矩阵压缩、二维矩阵前缀和）**
- **识图谱新词挖掘（滑动窗口）**
- 查找充电设备组合（背包问题）
- **区块链文件转储系统（滑动窗口、双指针）**
- 上班之路（深度优先搜索）
- 最小传输延迟（深度优先搜索）
- TLV解析（字符串操作）
- 内存资源分配（逻辑分析）
- 人数最多的站点（区间问题、最大区间重叠数、差分数列）
- 快递投递问题（逻辑分析）
- 机房布局（栈结构、区间问题）
- 静态扫描（贪心思维）
- 优秀学员统计（排序）
- 异常的打卡记录（逻辑分析）
- 分奖金（栈结构）
- 整理扑克牌（逻辑分析）
- **等和子数组最小和（回溯）**
- **最优高铁城市修建方案**
- **工作安排**|**最大报酬**
- **简单的自动曝光**
- **找等值元素**
- **静态扫描**
- **信号强度**
- **寻找符合要求的最长子串**
- **检测热点字符**
- **匿名信**
- **优选核酸监测点**
- **最左侧冗余覆盖子串**
- **工单调度策略**
- **无向图渲染**
- **任务调度**
- **采样过滤**
- **真正的密码**
- **最多颜色的车辆**
- **查找重复代码**
- **投篮大赛**
- **开心消消乐**
- **网上商城优惠活动（一）**
- **完美走位**
- 羊、狼、**农夫过河**
- **密室逃生游戏**
- **荒地建设电站**
- **租车骑绿岛**
- **箱子之字形摆放**
- MVP**争夺战**
- **字符串重新排列**







# ***************************************************新*******************************************************

按照频数降序排列

#  一、100分



## 01 预定酒店（0174）（排序、二分查找）ok

**题目描述**

放暑假了，小明决定到某旅游景点游玩，他在网上搜索到了各种价位的酒店（长度为n的数组A），他的心理价位是x元，请帮他筛选出k个最接近x元的酒店（n>=k>0）,并由低到高打印酒店的价格。

**输入描述**

第一行：`n, k, x`
第二行：`A[0] A[1] A[2]...A[n-1]`

**输出描述**

从低到高打印筛选出的酒店价格

**示例一**

**输入**

```plaintext
10 5 6
1 2 3 4 5 6 7 8 9 10
```

**输出**

```plaintext
4 5 6 7 8
```

**示例二**

**输入**

```plaintext
10 4 6
10 9 8 7 6 5 4 3 2 1
```

**输出**

```plaintext
4 5 6 7
```

**说明**

数组长度`n = 10`，筛选个数`k = 4`，目标价位`x = 6`
当`4`和`8`距离`x`相同时，优先选择价格低的`4`

**示例三**

**输入**

```plaintext
6 3 1000
30 30 200 500 70 300
```

Copy

**输出**

```plaintext
200 300 500
```

**备注**

1. 酒店价格数组A和小明的心理价位x均为整型数据；(0<n,k,x<10000)
2. 优先选择价格最接近心理价位的酒店，若两家酒店和心理价位差价相同，则选择价格较低的酒店。（比如100元和300元距离心理价位200元同样接近，此时选择100元）
3. 酒店价格可能相同重复

## 02 整理扑克牌（0198）（贪心、排序）ok

**题目描述**

给定一组数字，表示扑克牌的牌面数字，忽略扑克牌的花色，请安如下规则对这一组扑克牌进行整理。

- 步骤一：

  对扑克牌进行分组，规则如下

  1. 当牌面数字相同张数大于等于`4`时，组合牌为`炸弹`；
  2. `三张相同牌面数字+两张`相同牌面数字，且三张牌与两张牌不相同时，组合牌为`葫芦`；
  3. `三张相同牌面数字`，组合牌为`三张`，
  4. `两张相同牌面数字`，组合牌为`对子`，
  5. 剩余没有相同的牌则为`单张`

- 步骤二：

  对上述组合牌进行由大到小排列，规则如下：

  1. 不同类型组合牌之间由大到小排列规则：
     炸弹 > 葫芦 > 三张 > 对子 > 单张
  2. 相同类型组合牌之间，除葫芦外，按组合牌全部牌面数字加总，由大到小排列
  3. 葫芦则先按三张相同牌面数字加总，由大到小排列，三张相同牌面数字加总相同时，再按另外两张牌面数字加总，由大到小排列；
  4. 由于葫芦大于三张，因此如果能形成更大的组合牌，也可以将三张拆分为两张或一张，其中的两张可以和其他三张重新组合成葫芦，剩下的一张为单张；

- 步骤三：

  1. 当存在多个可能组合方案时，按如下规则排序取最大的一个组合牌：
  2. 依次对组合方案中的组合牌进行大小比较，规则同上；
  3. 当组合方案A中的第N个组合牌 > 组合方案B中的第N个组合牌时，即组合方案A大于组合方案B；

**输入描述**

第一行为空格分隔的N个正整数，每个整数取值范围 [1,13][1,13]，N的取值范围 [1,1000][1,1000]

**输出描述**

经重新排列后的扑克牌数字列表，每个数字以空格分隔

**示例一**

**输入**

```plaintext
1 3 3 3 2 1 5
```

**输出**

```plaintext
3 3 3 1 1 5 2
```

**示例二**

**输入**

```plaintext
4 4 2 1 2 1 3 3 3 4
```

**输出**

```plaintext
4 4 4 3 3 2 2 1 1 3
```



## 03 单入口空闲区域（0180）（递归、数组、DFS搜索）ok



## 04 日志采集系统（0186）（数组）ok



##  05 异常打卡记录（0205）（数组、字符串）ok

**题目描述**

考勤记录是分析和考核职工工作时间利用情况的原始依据，也是计算职工工资的原始依据，
为了正确地计算职工工资和监督工资基金使用情况，公司决定对员工的手机打卡记录进行异常排查。
如果出现以下两种情况，则认为打卡异常：

1. 实际**设备号与注册设备号不一样**
2. 或者，同一个员工的**两个打卡记录的时间小于60分钟并且打卡距离超过5km**。
   给定打卡记录的字符串数组`clockRecords`（每个打卡记录组成为：工号,时间（分钟）,打卡距离（km）,实际设备号,注册设备号），返回其中异常的打卡记录（按输入顺序输出）。

**输入描述**

第一行输入为 *N*，表示打卡记录数；
之后的 *N* 行为打卡记录，每一行为一条打卡记录。

例如：

```plaintext
2
100000,10,1,ABCD,ABCD
100000,50,10,ABCD,ABCD
```

**输出描述**

输出为异常的打卡记录，例如：`100000,10,1,ABCD,ABCD;100000,50,10,ABCD,ABCD`

**备注**

1. `clockRecords长度 <= 1000`；
2. `clockRecords[i]`格式：`{id},{time},{distance},{actualDeviceNumber},{registeredDeviceNumber}`
3. `id`由`6`位数字组成；
4. `time`由整数组成，范围为`0 ~ 1000`；
5. `distance`由整数组成，范围为`0 ~ 100`；
6. `actualDeviceNumber`与`registeredDeviceNumber`由四位大写字母组成。

**示例一**

**输入**

```plaintext
2
100000,10,1,ABCD,ABCD
100000,50,10,ABCD,ABCD
```

**输出**

```plaintext
100000,10,1,ABCD,ABCD;100000,50,10,ABCD,ABCD
```

**说明**

第一条记录是异常的，因为第二条记录与它的间隔不超过60分钟但是打卡距离超过了5km，同理第二条记录也是异常的。

**示例二**

**输入**

```plaintext
2
100000,10,1,ABCD,ABCD
100000,80,10,ABCE,ABCD
```

**输出**

```plaintext
100000,80,10,ABCE,ABCD
```

**说明**

第二条记录的注册设备号与打卡设备号不一致，所以是异常记录

**示例三**

**输入**

```plaintext
2
100000,10,1,ABCD,ABCD
100001,80,10,ABCE,ABCE
```

**输出**

```plaintext
null
```

**说明**

无异常打卡记录，所以返回`null`



 ## 06 简单的自动曝光（0185）（数组）ok

**题目描述**

一个图像有`n`个像素点，存储在一个长度为`n`的数组`img`里，每个像素点的取值范围`[0,255]`的正整数。
请你给图像每个像素点值加上一个整数`k`（可以是负数），得到新图`newImg`，使得新图`newImg`的所有像素平均值最接近中位值`128`。
请输出这个整数`k`。

**输入描述**

`n`个整数，中间用空格分开
例如：
`0 0 0 0`
4个数值，中间用空格分开

**输出描述**

一个整数`k`

备注：

- 1≤*n*≤100
- 如有多个整数*k* 都满足，输出小的那个 *k*；
- 新图的像素值会自动截取到 [0,255] 范围。`当新像素值<0，其值会更改为0；当新像素值>255，其值会更改为255`；
  例如`newImg="-1 -2 256"`,会自动更改为`"0 0 255"`

**示例一**

**输入**

```plaintext
0 0 0 0
```

**输出**

```plaintext
128
```

**说明**

四个像素值都为0

**示例二**

**输入**

```plaintext
129 130 129 130
```

**输出**

```plaintext
-2
```

**说明**

```
-1的均值128.5，-2的均值为127.5，输出较小的数-2
```



## 07 数组的中心位置（0187）（数组、前缀和）ok



## 08 找数字、找等值元素（0197）（数组）ok

**题目描述**

给一个二维数组`nums`，对于每一个元素`num[i]`，找出距离最近的且值相等的元素，输出横纵坐标差值的绝对值之和，如果没有等值元素，则输出`-1`。
例如：
输入数组`nums`为

```plaintext
0 3 5 4 2
2 5 7 8 3
2 5 4 2 4
```

对于 `num[0][0] = 0`，不存在相等的值。
对于 `num[0][1] = 3`，存在一个相等的值，最近的坐标为`num[1][4]`，最小距离为`4`。
对于 `num[0][2] = 5`，存在两个相等的值，最近的坐标为`num[1][1]`，故最小距离为`2`。
...
对于 `num[1][1] = 5`，存在两个相等的值，最近的坐标为`num[2][1]`，故最小距离为`1`。
...
故输出为

```plaintext
-1 4  2  3 3
 1 1 -1 -1 4
 1 1  2  3 2
```

**输入描述**

输入第一行为二维数组的行
输入第二行为二维数组的列
输入的数字以空格隔开。

**输出描述**

数组形式返回所有坐标值。

**备注**

1. 针对数组`num[i][j]`，满足 0<*i*≤100；0<*j*≤100。
2. 对于每个数字，最多存在 100100 个与其相等的数字。

**示例一**

**输入**

```plaintext
3
5
0 3 5 4 2
2 5 7 8 3
2 5 4 2 4
```

**输出**

```plaintext
[[-1, 4, 2, 3, 3], [1, 1, -1, -1, 4], [1, 1, 2, 3, 2]]
```



## 09 新员工座位安排系统(0204)(数组、滑窗) ok

**题目描述**

工位由序列 $$F_1,F_2...F_n $$组成， $$F_i$$ 值为 0 、1 或 2 ，其中 0 代表空置，1 代表有人，22代表障碍物。

1. 某一空位的友好度为左右连续老员工工数之和
2. 为方便新员工学习求助，优先安排友好度高的空位；
   给出工位序列，求所有空位中友好度的最大值。

**输入描述**

第一行为工位序列:  $$F_1,F_2...F_n $$ 组成，1≤*n*≤100000 ，$$F_i$$ 值为 0 、1 或 2 ，其中 0 代表空置，1 代表有人，2 代表障碍物。

**输出描述**

所有空位中友好度的最大值。如果没有空位，返回 00。

**示例一**

**输入**

```plaintext
0 1 0
```

**输出**

```plaintext
1
```

**示例二**

**输入**

```plaintext
1 1 0 1 2 1 0
```

**输出**

```plaintext
3
```







## 10 相同数字的积木游戏1(0171)(数组) ok



**题目描述**

小华和小薇一起通过玩积木游戏学习数学。
他们有很多积木，每个积木块上都有一个数字，
积木块上的数字可能相同。
小华随机拿一些积木挨着排成一排，请小薇找到这排积木中数字相同且所处位置最远的2块积木块，计算他们的距离。
小薇请你帮忙替她解决这个问题。

**输入描述**

第一行输入为 N ，表示小华排成一排的积木总数。
接下来 *N* 行每行一个数字，表示小花排成一排的积木上数字。

**输出描述**

相同数字的积木的位置最远距离；
如果所有积木数字都不相同，请返回 `-1`

**示例一**

**输入**

```plaintext
5
1
2
3
1
4
```

**输出**

```plaintext
3
```

**示例一**

**输入**

```plaintext
2
1
2
```

**输出**

```plaintext
-1
```

**备注**

```
0 <= 积木上的数字 < 10^9
1 <= 积木长度 <= 10^5
```





## 11 找出通过车辆最多颜色（0209）（数组）ok

**题目描述**

在一个狭小的路口，每秒只能通过一辆车，
假如车辆的颜色只有`3`种，找出 *N* 秒内经过的最多颜色的车辆数量，
三种颜色编号为`0`，`1`，`2`

**输入描述**

第一行输入的是通过的车辆颜色信息
`[0,1,1,2]` 代表`4`秒钟通过的车辆颜色分别是`0,1,1,2`
第二行输入的是统计时间窗，整型，单位为秒

**输出描述**

输出指定时间窗内经过的最多颜色的车辆数量

**示例一**

**输入**

```plaintext
0 1 2 1
3
```

**输出**

```plaintext
2
```

**说明**

在`[1,2,1]`这个3秒时间窗内，`1`这个颜色出现`2`次，数量最多

**示例二**

**输入**

```plaintext
0 1 2 1
2
```

**输出**

```plaintext
1
```

**说明**

在`2`秒时间窗内，每个颜色最多出现`1`次

**思路**

1. 用map保存时间窗口内的车辆颜色和数量
2. 时间每过1s，
   1. 如果总时间不足窗口长度，则直接更新颜色计数
   2. 如果总时间超过窗口长度，则先移除最早的数据，再更新颜色计数
   3. 更新出现最高的颜色数量









## 12 AI处理器组合（0221）（数组、回溯）（格式问题，先放着吧）half ok

**（这题目和例子我直接看蒙了，说的不清楚）**

**题目描述**

某公司研发了一款高性能AI处理器。每台物理设备具备8颗AI处理器，编号分别为0、1、2、3、4、5、6、7。编号0-3的处理器处于同一个链路中，编号4-7的处理器处于另外一个链路中，不通链路中的处理器不能通信，如下图所示。现**给定服务器可用的处理器编号数组array**，以及**任务申请的处理器数量num**，找出**符合**下列亲和性调度**原则**的**芯片组合**。如果不存在符合要求的组合，则返回空列表。
亲和性调度原则：

- 如果申请处理器个数为1，则选择同一链路，剩余可用的处理器数量为1个的最佳，其次是剩余3个的为次佳，然后是剩余2个，最后是剩余4个。
- 如果申请处理器个数为2，则选择同一链路剩余可用的处理器数量2个的为最佳，其次是剩余4个，最后是剩余3个。
- 如果申请处理器个数为4，则必须选择同一链路剩余可用的处理器数量为4个。
- 如果申请处理器个数为8，则申请节点所有8个处理器。
  提示：

1. 任务申请的处理器数量只能是1、2、4、8
2. 编号0-3的处理器处于一个链路，编号4-7的处理器处于另外一个链路。
3. 处理器编号唯一，且不存在相同编号处理器
   ![p0221.png](https://wiki.amoscloud.com/adecco/p0221.png)

**输入描述**

输入包含可用的处理器编号数组`array`，以及任务申请的处理器数量`num`两个部分。
第一行为`array`，第二行为`num`。例如：

```plaintext
[0, 1, 4, 5, 6, 7]
1
```

表示当前编号为0、1、4、5、6、7的处理器可用。任务申请1个处理器。
`0<= array.length <= 8`
`0<= array[i] <= 7`
`num in [1, 2, 4, 8]`

**输出描述**

输出为组合列表，当`array = [0, 1, 4, 5, 6, 7]` ，`num = 1`时，输出为`[[0], [1]]`

**示例一**

**输入**

```plaintext
[0, 1, 4, 5, 6, 7]
1
```

**输出**

```plaintext
[[0], [1]]
```

**说明**

根据第一条亲和性调度原则，在剩余两个处理器的链路（0,1,2,3）中选择处理器。由于只有0和1可用，则返回任意一颗处理器即可

**示例二**

**输入**

```plaintext
[0, 1, 4, 5, 6, 7]
4
```

**输出**

```plaintext
[[4, 5, 6, 7]]
```

**说明**

根据第三条亲和性调度原则，必须选择同一链路剩余可用的处理器数量为4个的环。



**我的理解：**

假设链路1中可用处理器为 0,1,2；链路2中可用处理器为5,6。第一行输入就是[0,1,2,5,6]

申请任务处理的服务器数量为1；（就是说要从链路1或2中选取1个服务器来处理任务）

按照规则1：在可用处理器数量为3的链路1中任选一个即可，那么输出就是：[[0],[1],[2]]（输出的是组合，即选0、1、2都可）

如果申请数为2：按照规则2，在可用处理器数量为2的链路2中选择，因为链路2只有2个，都选，输出：[[5,6]]



题目的描述：**则选择同一链路，剩余可用的处理器数量为x个的最佳**可能有歧义。把这个剩余删掉可能好理解一点。





## 13 光伏场地建设规划（0224）（数组、动态规划）ok

**题目描述**

祖国西北部有一片大片荒地，其中零星的分布着一些湖泊，保护区，矿区；整体上常年光照良好，但是也有一些地区光照不太好。某电力公司希望在这里建设多个光伏电站，生产清洁能源。对每平方公里的土地进行了发电评估，其中不能建设的区域发电量为0kw，可以发电的区域根据光照，地形等给出了**每平方公里年发电量x千瓦**。我们希望能够找到其中**集中的矩形区域**建设电站，能够获得良好的收益。

**输入描述**

第一行输入为调研的地区**长，宽**，以及准备建设的电站【长宽相等，为正方形】的**边长**，最低要求的**发电量**
之后每行为调研区域每平方公里的发电量
例如，输入为：
2 5 2 6
1 3 4 5 8
2 3 6 7 1
表示调研的区域大小为长2宽5的矩形，我们要建设的电站的边长为2，建设电站最低发电量为6

**输出描述**

输出为这样的**区域有多少个**
上述输入长宽为2的正方形满足发电量大于等于6的区域有4个。
则输出为：
4

**备注**

其中 被调研的区域的长宽均大于等于1，建设电站的边长大于等于1，任何区域的发电量大于等于0

**示例一**

**输入**

```plaintext
2 5 2 6
1 3 4 5 8
2 3 6 7 1
```

**输出**

```plaintext
4
```

**说明**

输入长为2，宽为5的场地，建设的场地为正方形场地，边长为2，要求场地的发电量大于等于6

**示例二**

**输入**

```plaintext
2 5 1 6
1 3 4 5 8
2 3 6 7 1
```

**输出**

```plaintext
3
```

**说明**

输入长为2，宽为5的场地，建设的场地为正方形场地，边长为1，要求场地的发电量大于等于0

**示例三**

**输入**

```plaintext
2 5 1 0
1 3 4 5 8
2 3 6 7 1
```

**输出**

```plaintext
10
```

**说明**

输入长为2，宽为5的场地，建设的场地为正方形场地，边长为1，要求场地的发电量大于等于0即可



## 14  字符串重新排序（）（字符串、排序、数组）sbbbb



**题目描述：**

给定一个字符串s，s包括以空格分隔的若干个单词，请对s进行如下处理后输出：

1、单词内部调整：**对每个单词字母重新按字典序排序**

2、单词间顺序调整：

1）统计每个单词出现的次数，并按**次数**降序排列

2）次数相同，按单词**长度**升序排列

3）次数和单词长度均相同，按**字典升序**排列

请输出处理后的字符串，每个单词以一个空格分隔。

**输入描述：**

一行字符串，每个字符取值范围：【a-z A-z 0-9】以及空格，字符串长度范围：【1，1000】

**示例1：**

**输入**

```
This is an apple
```

**输出**

```
an is This aelpp
```

**示例2：**

**输入：**

```
My sister is in the house not in the yard
```

**输出：**

```
in in eht eht My is not adry ehosu eirsst
```



## 15  获得完美走位（0184）（字符串、滑窗）ok



## 16  通信误码（0169）（字符串、数组）ok



## 17 获得最大软件版本号 （0190）（字符串、排序）ok

**题目描述**

Maven版本号定义，`<主版本>.<次版本>.<增量版本>-<里程碑版本>`
举例`3.1.4-beta` 其中，主版本和次版本都是必须的，主版本，次版本，增量版本由多位数字组成，可能包含前导零，里程碑版本由字符串组成。
`<主版本>.<次版本>.<增量版本>`：基于数字比较
`里程碑版本`：基于字符串比较,采用字典序
比较版本号时，按从左到右的顺序依次比较。基于数字比较， 只需比较忽略任何前导零后的整数值 。
输入2个版本号，输出最大版本号

**输入描述**

输入2个版本号，换行分割，每个版本的最大长度小于50

**输出描述**

版本号相同时输出第一个输入版本号

**备注**

主版本，次版本，增量版本：基于字符串比较,比如

```
1.5 > 1.4 > 1.3.11 > 1.3.9
里程碑版本：基于字符串比较 比如
1.2-beta-3 > 1.2-beta-11
```

**示例一**

**输入**

```plaintext
2.5.1-C
1.4.2-D
```

**输出**

```plaintext
2.5.1-C
```

**说明**

主版本，数字`2`大于`1`

**示例二**

**输入**

```plaintext
1.3.11-S2
1.3.11-S13
```

输出

```plaintext
1.3.11-S2
```

**说明**

里程碑版本，`S2`大于`S13`

**示例三**

**输入**

```plaintext
1.05.1
1.5.01
```

**输出**

```plaintext
1.05.1
```

**说明**

版本号相同，输出第一个版本号

**示例四**

**输入**

```plaintext
1.5
1.5.0
```

**输出**

```plaintext
1.5.0
```

**说明**

主次相同，存在增量版本大于不存在

**示例五**

**输入**

```plaintext
1.5.1-A
1.5.1-a
```

**输出**

```plaintext
1.5.1-a
```

**说明**

里程碑版本号，字符串比较`a`大于`A`

## 18  查找重复代码（0177）（字符串、动态规划）ok





# 二、200分



## 01（）（）



## 02 （）（）



# .选项说明

```

```
